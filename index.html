<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Itinerary Player – Map Recorder & Replayer</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#22c1c3;--muted:#9aa4b2}
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;color:#e6eef6;background:linear-gradient(180deg,#071022 0%, #071a2a 100%)}
    .app{max-width:1100px;margin:28px auto;padding:18px;border-radius:12px;background:rgba(255,255,255,0.02);box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .top{display:flex;gap:12px;align-items:center}
    h1{font-size:18px;margin:0;color:var(--accent)}
    .controls{margin-left:auto;display:flex;gap:12px;align-items:center}
    .btn{background:linear-gradient(180deg,#0f1728,#0b1730);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;color:#cfeef1;cursor:pointer;text-align:center;transition:all 0.3s ease}
    .button-group{display:flex;gap:10px;align-items:center}
    .button-group .btn{min-width:130px}
    .btn.primary{background:linear-gradient(90deg,#13b8b9,#2ec7ae);color:#022}
    .btn.loaded{border:2px solid #13b8b9;box-shadow:0 0 15px rgba(19,184,185,0.5);background:linear-gradient(180deg,#0f1728,#0b1730)}
    .btn .tick{display:none;margin-left:6px;color:#13b8b9;font-weight:bold}
    .btn.loaded .tick{display:inline}
    input[type=file]{display:none}
    .layout{display:grid;grid-template-columns:1fr 320px;gap:14px;margin-top:14px}
    .viewer{position:relative;border-radius:8px;overflow:hidden;background:#071221;min-height:560px;cursor:crosshair}
    canvas{display:block}
    .sidebar{padding:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px}
    label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
    .small{font-size:13px;color:#cfeef1}
    .row{display:flex;gap:8px;align-items:center;margin-top:8px}
    .speed{width:150px}
    .actions{display:flex;gap:8px;margin-top:12px}
    .actions .btn{flex:1}
    .info{font-size:13px;color:var(--muted);margin-top:8px}
    .footer{margin-top:12px;font-size:12px;color:var(--muted)}
    .file-name{font-size:13px;color:#cfeef1;max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .hint{font-size:13px;color:#9fb4bd}
    .fullscreen-btn{position:absolute;bottom:12px;right:12px;z-index:10;background:linear-gradient(180deg,#0f1728,#0b1730);border:1px solid rgba(255,255,255,0.1);padding:10px 16px;border-radius:8px;color:#cfeef1;cursor:pointer;font-size:13px;box-shadow:0 4px 12px rgba(0,0,0,0.3)}
    .fullscreen-btn:hover{background:linear-gradient(180deg,#13b8b9,#0b1730);border-color:rgba(255,255,255,0.2)}
    .fullscreen-controls{position:absolute;bottom:12px;right:12px;z-index:10;display:none;gap:10px;align-items:center}
    .fullscreen-controls.active{display:flex}
    .pan-speed-control{position:absolute;bottom:12px;left:12px;z-index:10;display:none;gap:10px;align-items:center;background:linear-gradient(180deg,#0f1728,#0b1730);border:1px solid rgba(255,255,255,0.1);padding:10px 16px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.3)}
    .pan-speed-control.active{display:flex}
    .pan-speed-control label{margin:0;color:#9fb4bd;font-size:13px}
    .pan-speed-control input[type="range"]{width:120px}
    .viewer.fullscreen-mode{position:fixed;top:0;left:0;right:0;bottom:0;width:100vw!important;height:100vh!important;z-index:9999;border-radius:0;margin:0}
    .viewer.fullscreen-mode canvas{width:100%;height:100%}
    .recording-toggle{background:linear-gradient(180deg,#e63946,#c1121f);border:1px solid rgba(255,255,255,0.1);padding:4px 10px;border-radius:6px;color:#fff;cursor:pointer;font-size:12px;margin-left:8px;font-weight:600}
    .recording-toggle:hover{background:linear-gradient(180deg,#ff4757,#e63946)}
    .recording-toggle.paused{background:linear-gradient(180deg,#2a9d8f,#1b7566);border-color:rgba(255,255,255,0.15)}
    .recording-toggle.paused:hover{background:linear-gradient(180deg,#3bb3a3,#2a9d8f)}
    .marker-size-input{width:60px}
    .separator{border-top:1px solid rgba(255,255,255,0.08);margin:16px 0}
    .inline-row{display:flex;gap:8px;align-items:center}
    .inline-row .small{margin:0}
    .section-title{font-size:13px;color:var(--muted);margin-top:10px;margin-bottom:4px}
    .status-row{display:flex;gap:12px;align-items:center;font-size:13px;color:#cfeef1;margin-top:8px}
    .status-item{display:flex;gap:6px;align-items:center}
    .main-actions{display:flex;gap:8px;margin-top:12px}
    .main-actions .btn{flex:1}
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <h1>Itinerary Player – Map Recorder & Replayer</h1>
      <div class="controls">
        <div class="button-group">
          <label class="btn" id="uploadMapBtn" for="fileInput">Upload map<span class="tick">✓</span></label>
          <input id="fileInput" type="file" accept="image/*">
          <label class="btn" id="uploadMarkerBtn" for="markerImageInput">Upload marker<span class="tick">✓</span></label>
          <input id="markerImageInput" type="file" accept="image/*">
        </div>
      </div>
    </div>

    <div class="layout">
      <div class="viewer" id="viewer">
        <canvas id="mapCanvas"></canvas>
        <canvas id="drawCanvas" style="position:absolute;left:0;top:0;pointer-events:auto"></canvas>
        <button id="fullscreenBtn" class="fullscreen-btn">⛶ Fullscreen</button>
        <div id="panSpeedControl" class="pan-speed-control">
          <label>Pan speed:</label>
          <input id="panSpeed" type="range" min="1" max="20" step="1" value="5">
          <span id="panSpeedLabel" style="color:#cfeef1;font-size:13px;min-width:30px">5</span>
        </div>
        <div id="fullscreenControls" class="fullscreen-controls">
          <button id="fullscreenPlayBtn" class="btn primary">Play</button>
          <button id="fullscreenClearBtn" class="btn">Clear drawing</button>
          <button id="fullscreenExitBtn" class="btn">⛶ Exit</button>
        </div>
      </div>

      <div class="sidebar">
        <div class="small"><strong>Controls</strong></div>
        
        <div class="status-row">
          <div class="status-item">
            <span style="color:var(--muted)">Status:</span>
            <span id="recordingState">idle</span>
          </div>
          <div class="status-item">
            <span style="color:var(--muted)">Length:</span>
            <span id="pathLen">0</span>
          </div>
          <div class="status-item">
            <span style="color:var(--muted)">Time:</span>
            <span id="recordingTime">0.00s</span>
          </div>
        </div>

        <div class="main-actions">
          <button id="playBtn" class="btn primary" style="flex:2">Play</button>
          <button id="recordToggle" class="recording-toggle" style="display:none;flex:1">Pause</button>
        </div>

        <label class="hint">Playback speed</label>
        <div class="row">
          <input id="speed" class="speed" type="range" min="0.1" max="2" step="0.05" value="1">
          <div id="speedLabel">1x</div>
        </div>

        <div class="actions">
          <button id="clearBtn" class="btn">Clear drawing</button>
        </div>

        <div class="separator"></div>

        <div class="section-title">Line & Marker Style</div>

        <div class="inline-row" style="margin-top:8px">
          <label class="small" style="min-width:70px">Line color</label>
          <input id="lineColor" type="color" value="#22c1c3">
          <label class="small" style="margin-left:8px;min-width:40px">Width</label>
          <input id="lineWidth" type="number" value="4" min="1" max="40" style="width:60px">
        </div>

        <div class="inline-row" style="margin-top:8px">
          <label class="small" style="min-width:80px">Marker size</label>
          <input id="markerSize" class="marker-size-input" type="number" value="25" min="1" max="100">
          <span class="small">px</span>
        </div>

        <div class="row" style="margin-top:8px">
          <label class="small"><input id="showMarker" type="checkbox" checked> show marker</label>
        </div>

        <div class="separator"></div>

        <div class="section-title">Data Management</div>
        <div class="actions">
          <button id="exportBtn" class="btn">Export JSON</button>
          <button id="importBtn" class="btn">Import JSON</button>
        </div>

        <div class="actions">
          <button id="savePNG" class="btn">Save PNG snapshot</button>
        </div>

        <div class="separator"></div>

        <div class="footer">Tip: Use mouse wheel to zoom, middle-click to pan.<br>Arrow keys or WASD to pan in fullscreen mode.</div>
      </div>
    </div>
  </div>

  <input id="hiddenJson" type="file" accept="application/json" style="display:none">

  <script>
    const mapCanvas=document.getElementById('mapCanvas');
    const drawCanvas=document.getElementById('drawCanvas');
    const viewer=document.getElementById('viewer');
    const mapCtx=mapCanvas.getContext('2d');
    const drawCtx=drawCanvas.getContext('2d');
    const fileInput=document.getElementById('fileInput');
    const uploadMapBtn=document.getElementById('uploadMapBtn');
    const uploadMarkerBtn=document.getElementById('uploadMarkerBtn');
    const recordingState=document.getElementById('recordingState');
    const pathLen=document.getElementById('pathLen');
    const recordingTime=document.getElementById('recordingTime');
    const playBtn=document.getElementById('playBtn');
    const speedRange=document.getElementById('speed');
    const speedLabel=document.getElementById('speedLabel');
    const showMarker=document.getElementById('showMarker');
    const lineWidthInput=document.getElementById('lineWidth');
    const lineColorInput=document.getElementById('lineColor');
    const clearBtn=document.getElementById('clearBtn');
    const exportBtn=document.getElementById('exportBtn');
    const importBtn=document.getElementById('importBtn');
    const hiddenJson=document.getElementById('hiddenJson');
    const savePNG=document.getElementById('savePNG');
    const fullscreenBtn=document.getElementById('fullscreenBtn');
    const fullscreenControls=document.getElementById('fullscreenControls');
    const fullscreenPlayBtn=document.getElementById('fullscreenPlayBtn');
    const fullscreenClearBtn=document.getElementById('fullscreenClearBtn');
    const fullscreenExitBtn=document.getElementById('fullscreenExitBtn');
    const recordToggle=document.getElementById('recordToggle');
    const markerImageInput=document.getElementById('markerImageInput');
    const markerSizeInput=document.getElementById('markerSize');
    const panSpeedControl=document.getElementById('panSpeedControl');
    const panSpeed=document.getElementById('panSpeed');
    const panSpeedLabel=document.getElementById('panSpeedLabel');

    let img=new Image();
    let mapLoaded=false;
    let path=[];
    let recording=false;
    let recordingPaused=false;
    let recordStart=0;
    let pausedRecordingTime=0;
    let playing=false;
    let pausedTime=0;
    let animationReq=null;
    let zoom=1;
    let offsetX=0;
    let offsetY=0;
    let isPanning=false;
    let startPan={x:0,y:0};
    let imgWidth=0;
    let imgHeight=0;
    let isFullscreen=false;
    let savedZoom=1;
    let savedOffsetX=0;
    let savedOffsetY=0;
    let markerImage=null;
    let markerImageLoaded=false;
    let panAnimationFrame=null;
    let keysPressed={};
    let timeUpdateInterval=null;

    function resizeCanvases(w,h){
      mapCanvas.width=drawCanvas.width=w;
      mapCanvas.height=drawCanvas.height=h;
      renderMap();
      redrawOverlay();
    }

    function renderMap(){
      mapCtx.setTransform(1,0,0,1,0,0);
      mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
      if(!mapLoaded)return;
      mapCtx.setTransform(zoom,0,0,zoom,offsetX,offsetY);
      mapCtx.drawImage(img,0,0);
    }

    function redrawOverlay(){
      drawCtx.setTransform(1,0,0,1,0,0);
      drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      if(path.length===0)return;
      drawCtx.setTransform(zoom,0,0,zoom,offsetX,offsetY);
      drawCtx.lineJoin='round';
      drawCtx.lineCap='round';
      drawCtx.lineWidth=Number(lineWidthInput.value||4)/zoom;
      drawCtx.strokeStyle=lineColorInput.value;
      drawCtx.beginPath();
      drawCtx.moveTo(path[0].x,path[0].y);
      for(let i=1;i<path.length;i++)drawCtx.lineTo(path[i].x,path[i].y);
      drawCtx.stroke();
    }

    function screenPos(e){
      const r=drawCanvas.getBoundingClientRect();
      const x=(e.clientX!==undefined?e.clientX:e.touches[0].clientX)-r.left;
      const y=(e.clientY!==undefined?e.clientY:e.touches[0].clientY)-r.top;
      return{x:(x-offsetX)/zoom,y:(y-offsetY)/zoom};
    }

    let isDown=false;

    function pointerDown(e){
      if(e.button===1){
        isPanning=true;
        startPan={x:e.clientX-offsetX,y:e.clientY-offsetY};
        viewer.style.cursor='grab';
        return;
      }
      e.preventDefault();
      
      // Auto-resume if recording is paused
      if(recordingPaused){
        recordingPaused=false;
        pausedRecordingTime+=performance.now()-lastPauseTime;
        // Resume time update interval
        if(!timeUpdateInterval){
          timeUpdateInterval=setInterval(updateInfo,50);
        }
        updateInfo();
      }
      
      isDown=true;
      const p=screenPos(e);
      if(!recording){
        recording=true;
        recordStart=performance.now();
        pausedRecordingTime=0;
        path=[];
        // Start time update interval
        if(timeUpdateInterval)clearInterval(timeUpdateInterval);
        timeUpdateInterval=setInterval(updateInfo,50);
      }
      const t=Math.round(performance.now()-recordStart-pausedRecordingTime);
      path.push({x:p.x,y:p.y,t});
      drawPoint(p.x,p.y);
      updateInfo();
    }

    function pointerMove(e){
      if(isPanning){
        offsetX=e.clientX-startPan.x;
        offsetY=e.clientY-startPan.y;
        renderMap();
        redrawOverlay();
        return;
      }
      if(!isDown||recordingPaused)return;
      e.preventDefault();
      const p=screenPos(e);
      const t=Math.round(performance.now()-recordStart-pausedRecordingTime);
      path.push({x:p.x,y:p.y,t});
      drawLineTo(p.x,p.y);
      updateInfo();
    }

    function pointerUp(e){
      if(e.button===1){
        isPanning=false;
        viewer.style.cursor='crosshair';
        return;
      }
      if(!isDown)return;
      e.preventDefault();
      isDown=false;
      drawCtx.closePath();
    }

    function drawPoint(x,y){
      drawCtx.setTransform(zoom,0,0,zoom,offsetX,offsetY);
      drawCtx.lineJoin='round';
      drawCtx.lineCap='round';
      drawCtx.lineWidth=Number(lineWidthInput.value||4)/zoom;
      drawCtx.strokeStyle=lineColorInput.value;
      drawCtx.beginPath();
      drawCtx.moveTo(x+0.1,y);
      drawCtx.lineTo(x,y);
      drawCtx.stroke();
    }

    function drawLineTo(x,y){
      drawCtx.lineTo(x,y);
      drawCtx.stroke();
    }

    function updateInfo(){
      if(recordingPaused){
        recordingState.textContent='paused';
        recordToggle.textContent='Resume';
        recordToggle.classList.add('paused');
      }else{
        recordingState.textContent=recording?'recording':'idle';
        if(recording){
          recordToggle.textContent='Pause';
          recordToggle.classList.remove('paused');
        }
      }
      recordToggle.style.display=recording||recordingPaused?'inline-block':'none';
      pathLen.textContent=path.length;
      
      // Update recording time
      if(recording||recordingPaused){
        const elapsed=(performance.now()-recordStart-pausedRecordingTime)/1000;
        recordingTime.textContent=elapsed.toFixed(2)+'s';
      }else{
        recordingTime.textContent='0.00s';
      }
    }

    function getTotalDuration(){
      return path.length===0?0:path[path.length-1].t;
    }

    function catmullRom(p0,p1,p2,p3,t){
      const t2=t*t;
      const t3=t2*t;
      return{
        x:0.5*((2*p1.x)+(p2.x-p0.x)*t+(2*p0.x-5*p1.x+4*p2.x-p3.x)*t2+(3*p1.x-p0.x-3*p2.x+p3.x)*t3),
        y:0.5*((2*p1.y)+(p2.y-p0.y)*t+(2*p0.y-5*p1.y+4*p2.y-p3.y)*t2+(3*p1.y-p0.y-3*p2.y+p3.y)*t3)
      };
    }

    function positionAt(elapsed){
      if(path.length===0)return null;
      if(elapsed<=path[0].t)return{x:path[0].x,y:path[0].y};
      if(elapsed>=path[path.length-1].t)return{x:path[path.length-1].x,y:path[path.length-1].y};
      let lo=0,hi=path.length-1;
      while(lo<hi){
        const m=Math.floor((lo+hi)/2);
        if(path[m].t<=elapsed)lo=m+1;
        else hi=m;
      }
      const i=Math.max(1,lo);
      const a=path[i-1],b=path[i];
      const segT=(elapsed-a.t)/(b.t-a.t);
      
      // Use Catmull-Rom spline for smooth interpolation
      const p0=i>=2?path[i-2]:path[i-1];
      const p1=path[i-1];
      const p2=path[i];
      const p3=i+1<path.length?path[i+1]:path[i];
      
      return catmullRom(p0,p1,p2,p3,segT);
    }

    function drawMarker(pos){
      const markerRadius=Number(markerSizeInput.value||25);
      
      if(markerImageLoaded&&markerImage){
        // Draw custom image as circular marker
        drawCtx.save();
        drawCtx.beginPath();
        drawCtx.arc(pos.x,pos.y,markerRadius/zoom,0,Math.PI*2);
        drawCtx.clip();
        const size=markerRadius*2/zoom;
        drawCtx.drawImage(markerImage,pos.x-markerRadius/zoom,pos.y-markerRadius/zoom,size,size);
        drawCtx.restore();
        
        // Add border
        drawCtx.beginPath();
        drawCtx.arc(pos.x,pos.y,markerRadius/zoom,0,Math.PI*2);
        drawCtx.lineWidth=2/zoom;
        drawCtx.strokeStyle='rgba(255,255,255,0.6)';
        drawCtx.stroke();
      }else{
        // Draw default red circle marker
        drawCtx.beginPath();
        drawCtx.fillStyle='rgba(255,80,80,0.95)';
        drawCtx.arc(pos.x,pos.y,markerRadius/zoom,0,Math.PI*2);
        drawCtx.fill();
        drawCtx.lineWidth=2/zoom;
        drawCtx.strokeStyle='rgba(255,255,255,0.6)';
        drawCtx.stroke();
      }
    }

    function drawPlaybackFrame(elapsed){
      drawCtx.setTransform(1,0,0,1,0,0);
      drawCtx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      if(path.length===0)return;
      drawCtx.setTransform(zoom,0,0,zoom,offsetX,offsetY);
      drawCtx.lineJoin='round';
      drawCtx.lineCap='round';
      drawCtx.lineWidth=Number(lineWidthInput.value||4)/zoom;
      drawCtx.strokeStyle=lineColorInput.value;
      drawCtx.beginPath();
      const pos=positionAt(elapsed);
      drawCtx.moveTo(path[0].x,path[0].y);
      for(let i=1;i<path.length;i++){
        if(path[i].t<=elapsed)drawCtx.lineTo(path[i].x,path[i].y);
        else{drawCtx.lineTo(pos.x,pos.y);break;}
      }
      drawCtx.stroke();
      if(showMarker.checked&&pos){
        drawMarker(pos);
      }
    }

    let playStart=0;
    let lastPauseTime=0;

    function animate(){
      const speed=Number(speedRange.value);
      const now=performance.now();
      const elapsed=(now-playStart+pausedTime)*speed;
      const total=getTotalDuration();
      if(elapsed>=total){
        drawPlaybackFrame(total);
        playing=false;
        playBtn.textContent='Play';
        fullscreenPlayBtn.textContent='Play';
        return;
      }
      drawPlaybackFrame(elapsed);
      animationReq=requestAnimationFrame(animate);
    }

    function togglePlay(){
      if(path.length<2){
        alert('Record at least two points.');
        return;
      }
      if(!playing){
        // Auto-pause recording when playback starts
        if(recording&&!recordingPaused){
          recordingPaused=true;
          lastPauseTime=performance.now();
          updateInfo();
        }
        
        // Reset if animation finished
        const total=getTotalDuration();
        const speed=Number(speedRange.value);
        const elapsed=(pausedTime)*speed;
        if(elapsed>=total){
          pausedTime=0;
        }
        
        playing=true;
        playStart=performance.now();
        playBtn.textContent='Pause';
        fullscreenPlayBtn.textContent='Pause';
        animate();
      } else {
        playing=false;
        cancelAnimationFrame(animationReq);
        pausedTime+=performance.now()-playStart;
        const total=getTotalDuration();
        const speed=Number(speedRange.value);
        const elapsed=(pausedTime)*speed;
        if(elapsed>=total){
          pausedTime=0;
          playBtn.textContent='Play';
          fullscreenPlayBtn.textContent='Play';
        } else {
          playBtn.textContent='Resume';
          fullscreenPlayBtn.textContent='Resume';
        }
      }
    }

    function clearDrawing(){
      path=[];
      recording=false;
      recordingPaused=false;
      pausedRecordingTime=0;
      playing=false;
      pausedTime=0;
      playBtn.textContent='Play';
      fullscreenPlayBtn.textContent='Play';
      cancelAnimationFrame(animationReq);
      if(timeUpdateInterval){
        clearInterval(timeUpdateInterval);
        timeUpdateInterval=null;
      }
      updateInfo();
      redrawOverlay();
    }

    recordToggle.addEventListener('click',()=>{
      if(!recording&&!recordingPaused)return;
      recordingPaused=!recordingPaused;
      if(recordingPaused){
        lastPauseTime=performance.now();
        // Stop time update interval when paused
        if(timeUpdateInterval){
          clearInterval(timeUpdateInterval);
          timeUpdateInterval=null;
        }
      }else{
        pausedRecordingTime+=performance.now()-lastPauseTime;
        // Resume time update interval when unpaused
        if(!timeUpdateInterval){
          timeUpdateInterval=setInterval(updateInfo,50);
        }
      }
      updateInfo();
    });

    fileInput.addEventListener('change',e=>{
      const f=e.target.files&&e.target.files[0];
      if(!f)return;
      const reader=new FileReader();
      reader.onload=ev=>{
        img=new Image();
        img.onload=()=>{
          mapLoaded=true;
          imgWidth=img.width;
          imgHeight=img.height;
          const viewerW=900;
          const viewerH=700;
          resizeCanvases(viewerW,viewerH);
          zoom=Math.min(viewerW/imgWidth,viewerH/imgHeight);
          offsetX=0;
          offsetY=0;
          renderMap();
          uploadMapBtn.classList.add('loaded');
        };
        img.src=ev.target.result;
      };
      reader.readAsDataURL(f);
    });

    markerImageInput.addEventListener('change',e=>{
      const f=e.target.files&&e.target.files[0];
      if(!f)return;
      const reader=new FileReader();
      reader.onload=ev=>{
        markerImage=new Image();
        markerImage.onload=()=>{
          // Resize if larger than 1024x1024
          if(markerImage.width>1024||markerImage.height>1024){
            const tempCanvas=document.createElement('canvas');
            const scale=Math.min(1024/markerImage.width,1024/markerImage.height);
            tempCanvas.width=markerImage.width*scale;
            tempCanvas.height=markerImage.height*scale;
            const tempCtx=tempCanvas.getContext('2d');
            tempCtx.drawImage(markerImage,0,0,tempCanvas.width,tempCanvas.height);
            const resizedImg=new Image();
            resizedImg.onload=()=>{
              markerImage=resizedImg;
              markerImageLoaded=true;
              uploadMarkerBtn.classList.add('loaded');
            };
            resizedImg.src=tempCanvas.toDataURL();
          }else{
            markerImageLoaded=true;
            uploadMarkerBtn.classList.add('loaded');
          }
        };
        markerImage.src=ev.target.result;
      };
      reader.readAsDataURL(f);
    });

    viewer.addEventListener('wheel',e=>{
      e.preventDefault();
      const rect=drawCanvas.getBoundingClientRect();
      const mouseX=e.clientX-rect.left;
      const mouseY=e.clientY-rect.top;
      
      const imgX=(mouseX-offsetX)/zoom;
      const imgY=(mouseY-offsetY)/zoom;
      
      const delta=e.deltaY<0?1.05:0.95;
      const newZoom=Math.min(Math.max(zoom*delta,0.05),20);
      
      offsetX=mouseX-imgX*newZoom;
      offsetY=mouseY-imgY*newZoom;
      zoom=newZoom;
      
      renderMap();
      redrawOverlay();
    });

    ['pointerdown','mousedown','touchstart'].forEach(ev=>drawCanvas.addEventListener(ev,pointerDown));
    ['pointermove','mousemove','touchmove'].forEach(ev=>drawCanvas.addEventListener(ev,pointerMove));
    ['pointerup','mouseup','touchend','pointercancel','mouseleave'].forEach(ev=>drawCanvas.addEventListener(ev,pointerUp));

    playBtn.addEventListener('click',togglePlay);
    speedRange.addEventListener('input',()=>speedLabel.textContent=speedRange.value+'x');
    clearBtn.addEventListener('click',clearDrawing);
    fullscreenClearBtn.addEventListener('click',clearDrawing);
    lineWidthInput.addEventListener('change',redrawOverlay);
    lineColorInput.addEventListener('input',redrawOverlay);

    exportBtn.addEventListener('click',()=>{
      if(path.length===0)return alert('No path');
      const data={path};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='itinerary.json';
      a.click();
    });

    importBtn.addEventListener('click',()=>hiddenJson.click());

    hiddenJson.addEventListener('change',e=>{
      const f=e.target.files&&e.target.files[0];
      if(!f)return;
      const r=new FileReader();
      r.onload=ev=>{
        try{
          const o=JSON.parse(ev.target.result);
          if(o.path){
            path=o.path;
            recording=false;
            recordingPaused=false;
            pausedRecordingTime=0;
            playing=false;
            pausedTime=0;
            playBtn.textContent='Play';
            fullscreenPlayBtn.textContent='Play';
            cancelAnimationFrame(animationReq);
            updateInfo();
            redrawOverlay();
          }
        }catch{
          alert('Invalid JSON');
        }
      };
      r.readAsText(f);
    });

    savePNG.addEventListener('click',()=>{
      const c=document.createElement('canvas');
      c.width=mapCanvas.width;
      c.height=mapCanvas.height;
      const ctx=c.getContext('2d');
      ctx.drawImage(mapCanvas,0,0);
      ctx.drawImage(drawCanvas,0,0);
      const url=c.toDataURL('image/png');
      const a=document.createElement('a');
      a.href=url;
      a.download='itinerary.png';
      a.click();
    });

    function enterFullscreen(){
      savedZoom=zoom;
      savedOffsetX=offsetX;
      savedOffsetY=offsetY;
      
      isFullscreen=true;
      viewer.classList.add('fullscreen-mode');
      fullscreenBtn.style.display='none';
      fullscreenControls.classList.add('active');
      panSpeedControl.classList.add('active');
      const w=window.innerWidth;
      const h=window.innerHeight;
      const oldW=900;
      const oldH=560;
      resizeCanvases(w,h);
      
      const scaleX=w/oldW;
      const scaleY=h/oldH;
      zoom=savedZoom*Math.min(scaleX,scaleY);
      offsetX=savedOffsetX*scaleX;
      offsetY=savedOffsetY*scaleY;
      
      renderMap();
      redrawOverlay();
      startKeyboardPan();
    }

    function exitFullscreen(){
      isFullscreen=false;
      viewer.classList.remove('fullscreen-mode');
      fullscreenBtn.style.display='block';
      fullscreenControls.classList.remove('active');
      panSpeedControl.classList.remove('active');
      resizeCanvases(900,560);
      
      zoom=savedZoom;
      offsetX=savedOffsetX;
      offsetY=savedOffsetY;
      
      renderMap();
      redrawOverlay();
      stopKeyboardPan();
    }

    fullscreenBtn.addEventListener('click',enterFullscreen);
    fullscreenExitBtn.addEventListener('click',exitFullscreen);
    fullscreenPlayBtn.addEventListener('click',togglePlay);

    panSpeed.addEventListener('input',()=>panSpeedLabel.textContent=panSpeed.value);

    function startKeyboardPan(){
      function panLoop(){
        if(!isFullscreen){
          stopKeyboardPan();
          return;
        }
        
        const speed=Number(panSpeed.value);
        let moved=false;
        
        if(keysPressed['ArrowUp']||keysPressed['w']||keysPressed['W']){
          offsetY+=speed;
          moved=true;
        }
        if(keysPressed['ArrowDown']||keysPressed['s']||keysPressed['S']){
          offsetY-=speed;
          moved=true;
        }
        if(keysPressed['ArrowLeft']||keysPressed['a']||keysPressed['A']){
          offsetX+=speed;
          moved=true;
        }
        if(keysPressed['ArrowRight']||keysPressed['d']||keysPressed['D']){
          offsetX-=speed;
          moved=true;
        }
        
        if(moved){
          renderMap();
          redrawOverlay();
        }
        
        panAnimationFrame=requestAnimationFrame(panLoop);
      }
      panLoop();
    }

    function stopKeyboardPan(){
      if(panAnimationFrame){
        cancelAnimationFrame(panAnimationFrame);
        panAnimationFrame=null;
      }
      keysPressed={};
    }

    document.addEventListener('keydown',e=>{
      if(isFullscreen){
        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','W','a','A','s','S','d','D'].includes(e.key)){
          e.preventDefault();
          keysPressed[e.key]=true;
        }
        if(e.key==='Escape'){
          exitFullscreen();
        }
      }
    });

    document.addEventListener('keyup',e=>{
      if(isFullscreen){
        delete keysPressed[e.key];
      }
    });

    resizeCanvases(900,560);
    updateInfo();
  </script>
</body>
</html>
